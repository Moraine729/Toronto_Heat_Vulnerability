# This script contains functions to further analysis Modis tif files and derive statistical results

from glob import glob
import os
import numpy as np
import geopandas as gpd
import rioxarray as rxr
import xarray as xr
import rasterio as rio

def open_modis(file_path): #given the path of the stored data, open all the tif file inside and return as a list. In addition, return the data_list contains all file names
    os.chdir(file_path)
    data_list = glob("*clip*.tif") #collect all the files that have been clipped in tif format
    storage = [] #create an empty list to store data
    for item in data_list: #open all raster data using loop
        storage.append(rxr.open_rasterio(item, masked=True))
    return storage, data_list

def concat_data(storage, file_list): #given the list stored all the data array and the list contains all file names, assign a new coordinate based on collect date and concat all datasets
    i = 0
    for i in range(len(storage)): #assign a new coordinate day which indicates the date where data collected
        storage[i] = storage[i].assign_coords({"day":int(file_list[i][-13:-10])})
        i = i + 1
    aggragate = xr.concat([storage[i] for i in range(len(storage))],"day") #concat all files based on day coordinate
    return aggragate

def count_exist_data(aggragate_data, input_crs): #given the aggragated datasets, for each pixel, count the number which has existing value recorded rather than nan
    #the input_crs parameter represents the coordinate system that should be assigned to this new combined xarray dataset, ususally, it is the loaded shapefile
    i = 0
    j = 0 #create to variable to represent x,y coordinate
    count_data = np.zeros((len(aggragate_data.x),len(aggragate_data.y))) #create an empty array to store output
    for i in range(len(aggragate_data.x)):
        for j in range(len(aggragate_data.y)): #loop over each pixel
            count_data[i,j] = np.sum(~np.isnan(aggragate_data.isel(x = i, y = j).data.flatten())) #for each pixel, flatten the data array into one dimension and count the number of non-nan appearence
            j = j + 1
        i = i + 1
    data_array = xr.DataArray(data = count_data.transpose(), dims=["y", "x"], coords=dict(y=(["y"], aggragate_data.y.data), x=([ "x"], aggragate_data.x.data)))
    #create a new xarray data arrray based on derived numpy array, assign the y, x coordinates to this new data array same as the input
    mod_data_array = data_array.rio.write_crs(input_crs.crs)
    return mod_data_array

def count_exceed(aggragate_data, threshold, input_crs): #given the aggragated datasets, for each pixel, count the number of times exceed the temperature threshold
    i = 0
    j = 0 #create to variable to represent x,y coordinate
    count_data = np.zeros((len(aggragate_data.x),len(aggragate_data.y))) #create an empty array to store output
    for i in range(len(aggragate_data.x)):
        for j in range(len(aggragate_data.y)): #loop over each pixel
            count_data[i,j] = np.sum(aggragate_data.isel(x = i, y = j).data.flatten() >= threshold) #for each pixel, flatten the data array into one dimension and count the number exceed threshold
            j = j + 1
        i = i + 1
    data_array = xr.DataArray(data = count_data.transpose(), dims=["y", "x"], coords=dict(y=(["y"], aggragate_data.y.data), x=([ "x"], aggragate_data.x.data)))
    #create a new xarray data arrray based on derived numpy array, assign the y, x coordinates to this new data array same as the input
    mod_data_array = data_array.rio.write_crs(input_crs.crs)
    return mod_data_array

def count_degree_day(aggragate_data, threshold, input_crs): #given the aggragated datasets, for each pixel, sum the degree days exceed the set threshold
    i = 0
    j = 0 #create to variable to represent x,y coordinate
    count_data = np.zeros((len(aggragate_data.x),len(aggragate_data.y))) #create an empty array to store output
    for i in range(len(aggragate_data.x)):
        for j in range(len(aggragate_data.y)): #loop over each pixel
            degree_day = 0 #intialize the degree day parameter for each pixel
            for item in aggragate_data.isel(x = i, y = j).data.flatten(): #loop over each item in this one dimension array to calculate degree days
                if item - threshold >= 0:
                    degree_day = degree_day + item - threshold
            count_data[i,j] = degree_day #store the degree_day into the numpy array
            j = j + 1
        i = i + 1
    data_array = xr.DataArray(data = count_data.transpose(), dims=["y", "x"], coords=dict(y=(["y"], aggragate_data.y.data), x=([ "x"], aggragate_data.x.data)))
    mod_data_array = data_array.rio.write_crs(input_crs.crs)
    return mod_data_array
