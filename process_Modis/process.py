#Functions to read and clip MODIS LST data in hdf format

import rioxarray as rxr
import geopandas as gpd
import rasterio as rio
import xarray as xr
import numpy as np
import pandas as pd
import os

def read_hdf(file_name): #read Modis data in hdf format
    modis_data = rxr.open_rasterio(file_name, masked=True)
    return modis_data

def clip_data(modis_data, clip_polygon): #reproject and clip the data based on Toronto shapefile
    modis_repr = modis_data.rio.reproject(clip_polygon.crs)
    modis_clip = modis_repr.rio.clip(clip_polygon.geometry,all_touched=True,from_disk=True)
    return modis_clip

def unit_conversion(modis_clip,band_name): #multiple the pixel value with scale factor and convert from Kelvin to Celsius
    scale = modis_clip[band_name].scale_factor #get scale factor from the data
    scale_modis = modis_clip[band_name] * scale - 273.15
    return scale_modis

def remove_mask(modis_data): #input scaled and cliped modis data and remove the non-data value around the area of interest
    valid_range = (-100, 100)
    if valid_range:
        mask = ((modis_data < valid_range[0]) | (modis_data > valid_range[1]))
        modis_mask = modis_data.where(~xr.where(mask, True, False))
    return modis_mask

def save_tif(scale_modis, file_name, file_title, file_path): #save the processed data in geotiff format and name based on original input
    current_dir = os.getcwd()
    output_name = file_title + file_name[8:16] + file_name[17:23] + ".tif"
    outPath = os.path.join(current_dir,file_path,output_name)
    modis_dir_path = os.path.dirname(outPath)
    if not os.path.exists(modis_dir_path): #create the directory if not exist
        os.mkdir(modis_dir_path)
    scale_modis.rio.to_raster(outPath)

def binary_convert(modis_qc): #input modis quality control data and return a dictionary contains the binary number and origianl number
    qc_array = modis_qc.data.squeeze() #extract only the data array and remove the first dimension
    item_list = np.unique(qc_array) #get all the possible value from the qc_array
    item_list = item_list[~np.isnan(item_list)] #remove nan from the array since its quality is proved
    binary_dict = dict() #create a new dict to store results
    for item in item_list: #loop all the value and store them in the dict
        binary_dict[item] = bin(int(item))
    return binary_dict

def count_qc(modis_qc,binary_dict): #input modis quality control data and corrosponding binary dictionary, returns the total number of pixels for each
    qc_array = modis_qc.data.squeeze() #extract the data from modis hdf file
    count_dict = binary_dict.copy() #create a copy of dict to store counts information
    for item in binary_dict: #loop over all numbers in dict
        counts = np.where(qc_array == item)
        count_dict[item] = len(counts[0]) #take the length of array's first dimension
    return count_dict

def analysis_qc(initial_qc_data): #read qc csv file and analysis the percentage of each type of error
    qc_data = initial_qc_data.copy() #generate a copy of input data
    cloud = []
    error_1k = []
    error_2k = []
    error_3k = []
    error_greater = []
    #create five lists to represent five types of errors
    i = 0
    for i in range(len(qc_data.columns)):
        if "{:08b}".format(int(float(qc_data.columns[i])))[-2:] == "10":
            cloud.append(i)
        else:
            if "{:08b}".format(int(float(qc_data.columns[i])))[:2] == "00":
                error_1k.append(i)
            elif "{:08b}".format(int(float(qc_data.columns[i])))[:2] == "01":
                error_2k.append(i)
            elif "{:08b}".format(int(float(qc_data.columns[i])))[:2] == "10":
                error_3k.append(i)
            elif "{:08b}".format(int(float(qc_data.columns[i])))[:2] == "11":
                error_greater.append(i)
        i = i + 1
    #use loop to assign each category with corrosponding column index
    qc_data.loc[:,"cloud_cover"] = 0
    qc_data.loc[:,"error_1k"] = 0
    qc_data.loc[:,"error_2k"] = 0
    qc_data.loc[:,"error_3k"] = 0
    qc_data.loc[:,"error_greater"] = 0
    #create 5 new columns for further calculations
    for item in error_1k:
        qc_data.loc[:,"error_1k"] = qc_data.loc[:,"error_1k"] + qc_data.iloc[:,item]
    qc_data.loc[:,"error_1k"] = qc_data.loc[:,"error_1k"]/861
    #
    for item in error_2k:
        qc_data.loc[:,"error_2k"] = qc_data.loc[:,"error_2k"] + qc_data.iloc[:,item]
    qc_data.loc[:,"error_2k"] = qc_data.loc[:,"error_2k"]/861
    #
    for item in error_3k:
        qc_data.loc[:,"error_3k"] = qc_data.loc[:,"error_3k"] + qc_data.iloc[:,item]
    qc_data.loc[:,"error_3k"] = qc_data.loc[:,"error_3k"]/861
    #
    for item in error_greater:
        qc_data.loc[:,"error_greater"] = qc_data.loc[:,"error_greater"] + qc_data.iloc[:,item]
    qc_data.loc[:,"error_greater"] = qc_data.loc[:,"error_greater"]/861
    #
    for item in cloud:
        qc_data.loc[:,"cloud_cover"] = qc_data.loc[:,"cloud_cover"] + qc_data.iloc[:,item]
    qc_data.loc[:,"cloud_cover"] = qc_data.loc[:,"cloud_cover"]/861
    #loop over the list and aggragate the percentage for each type of error
    return qc_data


def mask_day_data(modis_data):#for the input modis data in hdf format, replace the error greater than 2k with nan
    mask_number = [2.,129.,145.] #the list contains the qc number characteriszed as error greater than 2k
    mod_modis_data = modis_data.copy(deep = True) #create a copy of modis data
    for item in mask_number:
        i = 0
        j = 0
        for i in range (len(mod_modis_data.x) ):
            for j in range (len(mod_modis_data.y) ):
                if mod_modis_data.QC_Day.data[0,j,i] == item:
                    mod_modis_data.LST_Day_1km.data[0,j,i] = np.nan
                j = j+ 1
            i = i + 1
    return mod_modis_data

def mask_night_data(modis_data):#for the input modis data in hdf format, replace the error greater than 2k with nan
    mask_number = [2.,129.,145.] #the list contains the qc number characteriszed as error greater than 2k
    mod_modis_data = modis_data.copy(deep = True) #create a copy of modis data
    for item in mask_number:
        i = 0
        j = 0
        for i in range (len(mod_modis_data.x) ):
            for j in range (len(mod_modis_data.y) ):
                if mod_modis_data.QC_Night.data[0,j,i] == item:
                    mod_modis_data.LST_Night_1km.data[0,j,i] = np.nan
                j = j+ 1
            i = i + 1
    return mod_modis_data
